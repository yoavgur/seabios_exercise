+---- Stage 2 ----+
Seabios - Seabios is an open source implementation of a standard x86 BIOS. It can be used both on emulators (namely qemu and bachs), or on actual machines (from what I read, using coreboot).
This project is pretty handy for 2 reason:
	* Since BIOS doesn't have a clearly defined interface, this can provide a framework for how it should look and work - both for learning  and for use in general purpose open source projects.
	* Because of what I stated previously, BIOS's codes aren't really shared or published. This makes Seabios a really usefull open source implementation of it that can be used in projects like emulation.

I read from the README to just compile by running 'make', so I compiled it like that successfully. It then said to use 'out/bios.bin' when using Seabios with qemu, which looks to be a binary file (it's genereated by running checkrom.py on bios.bin.raw, which is generated by running '$(Q)$(OBJCOPY) -O binary rom.o $(OUT)bios.bin.raw').

I then ran the command 'qemu-system-x86_64 -bios out/bios.bin' to run a qemu virtual machine with my compiled bios. It did print in the beginning the BIOS was in fact Seabios, but I know that qemu uses Seabios by default - so to make sure that it was in fact my bios, I changed a printf in the boot prints (printf("YOAV: Booting from ROM...\n");). I then booted again and saw my printf :).


+---- Stage 3 ----+
1) The reset vector is physical memory address that the CPU instruction pointer points to upon reboot (0xFFFF0000:FFF0). In Seabios this is mapped to the assembly function 'reset_vector', which then long jumps to the assembly function 'entry_post' which is located in the BIOS segment, which then transitions to 32-bit mode and calls the c function 'handle_post'.

2) First, from previous reading I know that the BIOS checks if a media is bootable by copying the first 512 bytes and checking if they end with the bytes '55AA'. So, to see if I could convince it that it was bootable, I created a file of 510 zeros and then 55AA and Seabios recognized it as bootable and jumped to it! It then understandably got stuck since I hadn't written any code.
I then looked up simple bootloader implementations and learned from there to call BIOS interruptions in order to print to the screen. 
I compiled the assembly code using nasm and added padding so that the last 2 bytes would be 55AA.
I then ran the qemu machine like this: 'qemu-system-x86_64 -bios ../out/bios.bin -m 1024 -hda bootloader.bin' and got hello world after it booted from my hard drive.

3) I read the first 512 bytes of my partition to a file using dd: 'sudo dd if=/dev/sda of=mbr bs=512 count=1'.

4) So analyzing the code took me a bunch of time. I started off by going over the BIOS interrupts since it wasn't too hard to find documentation about them and they could give me a general sense of the code's flow. I also made note of which functions lead to dead ends and which did not to understand which results are good and which aren't.
The easy interrupts to understand were the extension check, the extended read and the read sectors. I assumed that the flow here would be to read the next sector and to jump to it after doing some checks. The weird thing here is that it looks like we're reading the next extension to 0x7c00, which is where we're running from. Seems like that shouldn't work...
The next thing that caught my attention was the interrupts relating to the keyboard. I learned that reading/writing to 0x60 is related to data transfer, while reading/writing to 0x64 is about commands to the keyboard and status. I read that before reading/writing you're supposed to read the read/write status bit from 0x64 before doing anything. I then saw that a function that does exactly that (loops a bunch of times on whether we can read yet or not).
Next we send the keyboard data which has the A20 gate bit on, which means we're turning on the A20 gate! This makes sense as we probably want to enter protected mode at some point.
The weird thing is that if the wait_until_can_read_from_keyboard function fails, we still jump to the next section without having turned on the A20 gate (I would expect this to fail). I guess the reason for this is that this flow would be for old systems. Weird.
The next part involves interrupts related to Trusted Computing Group. It looks like we're checking that this supports the TCG Bios interface and checks if the version is 1.2. If the the interface isn't supported, or the version is wrong, or the interrupt didn't return the expected output, we jump to a certain address. If not, we do another TCG interrupt. I was stuck on this for a while, because IDA said that it was the same interrupt which would be really weird. But after inspecting the pushes before the interrupt (and with a little help from the internet), I saw that the number BB07 was pushed onto the stack (which sounds suspicious since the previous interrupt identifier was BB00), and it looks like it's later retrieved into AX. 
After a while of looking for documentation about this, I found a pdf which described the different interrupts, but it says that between 07-07F they're reserved. After more searching a found a source (strangely in hebrew) that claimed that this interrupt is CompactHashLogExtendEvent_TCG, which does some kind of logging. I guess it makes sense then: If their interface is supported we use it to log something, if it isn't we just skip that part.
The next part it took me a while to understand. It looked like if we continue doing the flow that we wanted to, the last thing we do is jump back to 0x7c00, which is where we start running. I also didn't understand what the first bit of code of the program does.
When I finally did understand that, all the pieces suddenly came together. It looks like the first snippet of code copies the first 0x200 bytes (512) from 0x7c00 (where we are loaded) to address 0x600. It then pushes 0 and 61c to the stack so that when they call retf it'll jump to 0000:061c (which is the next line of code). This explains how we can copy the next sector to 0x7c00, and why we jump to it at the end. 
So, to summarize this with sudo code:

# First we're loaded to 0x7C00
# We then copy ourselves to 0x600 and continue running

for partition in partition_entries: #found at the end of our partition
	if partition is valid:
		for x in xrange(5):
			if has_extension_drive():
				is_success = do_extended_read(dst_address=0x7c00)
			else:
				is_success = do_read_sectors(dst_address=0x7c00)
			if is_success:
				if memory[0x7dfe:0x7e00] != 0x55AA:
					print "Invalid OS"
					exit()
				try_turning_on_A20_gate()
				if is_TCG_BIOS():
					write_tcg_logs()

				jump_to_7c00() # DONE!

			else:
				reset_disk()
		print "Error loading OS"
		exit()

	else:
		if partition_is_bad:
			print "Partition table entry invalid"
			exit()

# No valid partitions found
print "NO ROM BASIC" # as in int 0x18
exit()



+---- Stage 4 ----+